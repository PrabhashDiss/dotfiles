# Dotfiles - Bash Configuration Additions
# Source this file from your ~/.bashrc: source ~/Documents/dotfiles/shell/bashrc_additions

# Enhanced history settings
export HISTSIZE=10000
export HISTFILESIZE=20000
export HISTCONTROL=ignoredups:erasedups
shopt -s histappend

# Better directory navigation
alias ..='cd ..'
alias ...='cd ../..'
alias ....='cd ../../..'
alias ll='ls -alF'
alias la='ls -A'
alias l='ls -CF'
alias grep='grep --color=auto'
alias fgrep='fgrep --color=auto'
alias egrep='egrep --color=auto'

# Git shortcuts
alias gs='git status'
alias ga='git add'
alias gc='git commit'
alias gp='git push'
alias gl='git log --oneline'
alias gd='git diff'

# Development shortcuts
alias v='nvim'
alias vim='nvim'
alias py='python3'
alias pip='pip3'

# fzf enhanced aliases
if command -v fzf >/dev/null 2>&1; then
    # Edit multiple files with fzf and bat preview
    if command -v bat >/dev/null 2>&1; then
        alias vf='vim $(fzf -m --preview "bat --color=always {}")'
    elif command -v batcat >/dev/null 2>&1; then
        alias vf='vim $(fzf -m --preview "batcat --color=always {}")'
        # Create bat alias for batcat on Ubuntu
        alias bat='batcat'
    else
        alias vf='vim $(fzf -m --preview "cat {}")'
    fi
    
    # Find and cd to directory
    alias cdf='cd $(find . -type d | fzf)'
    
    # Kill process with fzf
    alias kp='kill -9 $(ps aux | fzf | awk "{print \$2}")'
fi

# System monitoring
alias df='df -h'
alias du='du -h'
alias free='free -h'
alias ps='ps aux'

# Network utilities
alias ping='ping -c 5'
alias ports='netstat -tulanp'

# fzf key bindings and fuzzy completion
if command -v fzf >/dev/null 2>&1; then
    # Source fzf key bindings (compatible with older versions)
    if [[ -f "/usr/share/doc/fzf/examples/key-bindings.bash" ]]; then
        source "/usr/share/doc/fzf/examples/key-bindings.bash"
    elif [[ -f "/usr/share/fzf/key-bindings.bash" ]]; then
        source "/usr/share/fzf/key-bindings.bash"
    fi
    
    # Source fzf completion for **<TAB> trigger
    if [[ -f "/usr/share/bash-completion/completions/fzf" ]]; then
        source "/usr/share/bash-completion/completions/fzf"
        # Set completion trigger (default is **)
        export FZF_COMPLETION_TRIGGER='**'
        
        # Set up completion for other commands
        if declare -F _fzf_setup_completion >/dev/null 2>&1; then
            _fzf_setup_completion path ls
            _fzf_setup_completion path cat
        fi
    fi
    
    # Custom fzf options
    export FZF_DEFAULT_OPTS='--height 40% --layout=reverse --border'
    export FZF_CTRL_T_OPTS="--preview 'cat {}' --preview-window=right:50%:wrap"
    export FZF_CTRL_R_OPTS="--preview 'echo {}' --preview-window down:3:hidden:wrap --bind '?:toggle-preview'"
    
    # Use bat for preview if available
    if command -v bat >/dev/null 2>&1; then
        export FZF_CTRL_T_OPTS="--preview 'bat --color=always {}' --preview-window=right:50%:wrap"
    elif command -v batcat >/dev/null 2>&1; then
        export FZF_CTRL_T_OPTS="--preview 'batcat --color=always {}' --preview-window=right:50%:wrap"
    fi
fi

# Better prompt with git branch info
parse_git_branch() {
    git branch 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/(\1)/'
}

if [[ $COLORTERM = gnome-* && $TERM = xterm ]] && infocmp gnome-256color >/dev/null 2>&1; then
    export TERM='gnome-256color'
elif infocmp xterm-256color >/dev/null 2>&1; then
    export TERM='xterm-256color'
fi

# Colored prompt
export PS1='\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[33m\]$(parse_git_branch)\[\033[00m\]\$ '

# Enable programmable completion features
if ! shopt -oq posix; then
    if [ -f /usr/share/bash-completion/bash_completion ]; then
        . /usr/share/bash-completion/bash_completion
    elif [ -f /etc/bash_completion ]; then
        . /etc/bash_completion
    fi
fi

# Export common development environment variables
export EDITOR=nvim
export VISUAL=nvim
export BROWSER=firefox
export PATH="$HOME/.local/bin:$PATH"

# Custom cd completion that handles fzf trigger
if command -v fzf >/dev/null 2>&1; then
    _cd_fzf() {
        local cur prev words cword
        # Basic completion initialization
        cur="${COMP_WORDS[COMP_CWORD]}"
        prev="${COMP_WORDS[COMP_CWORD-1]}"
        
        # Check if current word ends with **
        if [[ "$cur" == *"$FZF_COMPLETION_TRIGGER" ]]; then
            # Remove the trigger from current word
            local prefix
            if [[ "$cur" == "$FZF_COMPLETION_TRIGGER" ]]; then
                prefix=""
            else
                prefix="${cur%$FZF_COMPLETION_TRIGGER}"
            fi
            # Use fzf to select directory
            local selected
            if declare -F _fzf_compgen_dir >/dev/null 2>&1 && declare -F __fzf_comprun >/dev/null 2>&1; then
                selected=$(_fzf_compgen_dir "${prefix:-.}" | \
                    __fzf_comprun dir --prompt="cd> " \
                    --header="Select directory" 2>/dev/null || echo "")
                if [[ -n "$selected" ]]; then
                    COMPREPLY=("$prefix$selected")
                    return 0
                fi
            fi
            # Fallback: use regular fzf
            local dirs
            dirs=$(find "${prefix:-.}" -type d -not -path '*/\.*' 2>/dev/null | head -100)
            if [[ -n "$dirs" ]]; then
                selected=$(echo "$dirs" | fzf --prompt="cd> " --header="Select directory" 2>/dev/null || echo "")
                if [[ -n "$selected" ]]; then
                    COMPREPLY=("$selected")
                    return 0
                fi
            fi
        fi
        
        # Use basic directory completion for non-** cases
        COMPREPLY=($(compgen -d -- "$cur"))
    }
    
    # Set up the completion
    complete -F _cd_fzf -o nospace cd
fi
