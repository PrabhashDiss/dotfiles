# Dotfiles - Bash Configuration Additions
# Source this file from your ~/.bashrc: source ~/Documents/dotfiles/shell/bashrc_additions

# Add neovim to PATH
export PATH="$PATH:/opt/nvim-linux-x86_64/bin"

# Enhanced history settings
export HISTSIZE=10000
export HISTFILESIZE=20000
export HISTCONTROL=ignoredups:erasedups
shopt -s histappend

# Better directory navigation
alias ..='cd ..'
alias ...='cd ../..'
alias ....='cd ../../..'
alias ll='ls -alF'
alias la='ls -A'
alias l='ls -CF'
alias grep='grep --color=auto'
alias fgrep='fgrep --color=auto'
alias egrep='egrep --color=auto'

# Git shortcuts
alias gs='git status'
alias ga='git add'
alias gc='git commit'
alias gp='git push'
alias gl='git log --oneline'
alias gd='git diff'

# Development shortcuts
alias v='nvim'
alias vim='nvim'
alias py='python3'
alias pip='pip3'

# fzf enhanced aliases
if command -v fzf >/dev/null 2>&1; then
    # Find and cd to directory
    alias cdf='cd $(find . -type d | fzf)'

    # Kill process with fzf
    alias kp='kill -9 $(ps aux | fzf | awk "{print \$2}")'
fi

# System monitoring
alias df='df -h'
alias du='du -h'
alias free='free -h'
alias ps='ps aux'

# Network utilities
alias ping='ping -c 5'
alias ports='netstat -tulanp'

# fzf key bindings and fuzzy completion
if command -v fzf >/dev/null 2>&1; then
    # Source fzf key bindings (compatible with older versions)
    if [[ -f "/usr/share/doc/fzf/examples/key-bindings.bash" ]]; then
        source "/usr/share/doc/fzf/examples/key-bindings.bash"
    elif [[ -f "/usr/share/fzf/key-bindings.bash" ]]; then
        source "/usr/share/fzf/key-bindings.bash"
    fi

    # Source fzf completion for **<TAB> trigger
    if [[ -f "/usr/share/bash-completion/completions/fzf" ]]; then
        source "/usr/share/bash-completion/completions/fzf"
        # Set completion trigger (default is **)
        export FZF_COMPLETION_TRIGGER='**'

        # Set up completion for other commands
        if declare -F _fzf_setup_completion >/dev/null 2>&1; then
            _fzf_setup_completion path ls
            _fzf_setup_completion path cat
        fi
    fi

    # Custom fzf options
    export FZF_DEFAULT_OPTS='--height 40% --layout=reverse --border'
    export FZF_CTRL_T_OPTS="--preview 'cat {}' --preview-window=right:50%:wrap"
    export FZF_CTRL_R_OPTS="--preview 'echo {}' --preview-window down:3:hidden:wrap --bind '?:toggle-preview'"

    # Use bat for preview if available
    if command -v bat >/dev/null 2>&1; then
        export FZF_CTRL_T_OPTS="--preview 'bat --color=always {}' --preview-window=right:50%:wrap"
    fi

    # Function to open files in vim with fzf and bat preview
    vf_func() {
        local files=$(fzf -m --preview "bat --color=always {}")
        if [[ -n "$files" ]]; then
            vim $files
        fi
    }

    # Bind Ctrl+F to the function
    bind -x '"\C-f": vf_func'

    # Function to cd to selected git worktree using fzf
    gwf() {
        if ! git rev-parse --git-dir >/dev/null 2>&1; then
            echo "Not inside a git repository" >&2
            return 1
        fi

        local worktrees
        worktrees=$(git worktree list --porcelain 2>/dev/null | awk '/^worktree /{print $2}')

        if [[ -z "$worktrees" ]]; then
            echo "No worktrees found" >&2
            return 1
        fi

        local selected
        selected=$(echo "$worktrees" | fzf --height=40% --reverse --border)
        if [[ -n "$selected" ]]; then
            cd "$selected" || return
        fi
    }

    # Function to remove current git worktree if it's a worktree
    gwr() {
        if ! git rev-parse --git-dir >/dev/null 2>&1; then
            echo "Not inside a git repository" >&2
            return 1
        fi

        local current
        current=$(pwd -P)
        local toplevel
        toplevel=$(git rev-parse --show-toplevel 2>/dev/null || true)

        local worktrees
        worktrees=$(git worktree list --porcelain 2>/dev/null | awk '/^worktree /{print $2}')

        local main_worktree
        if [[ -n "$toplevel" && $(echo "$worktrees" | grep -Fx "$toplevel") ]]; then
            main_worktree=$toplevel
        else
            main_worktree=$(echo "$worktrees" | head -n1)
        fi

        # Check if current is a tracked worktree and not the main one
        if [[ -n "$(echo "$worktrees" | grep -Fx "$current")" ]] && [[ "$current" != "$main_worktree" ]]; then
            # Check for uncommitted changes in the worktree
            if ! git diff --quiet || ! git diff --staged --quiet; then
                echo "There are uncommitted changes. Please commit or stash them before removing the worktree." >&2
                return 1
            fi
            echo "Removing worktree: $current"
            cd "$main_worktree" || return
            git worktree remove "$current"
        else
            echo "Not in a removable worktree (or it's the main worktree)" >&2
            return 1
        fi
    }
fi

# Better prompt with git branch info
parse_git_branch() {
    git branch 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/ \1/'
}

# Colored prompt
export PS1='\[\033[02;34m\]\w\[\033[01;33m\]\040$(parse_git_branch)\040\[\033[00;37m\]\$ '

# Enable programmable completion features
if ! shopt -oq posix; then
    if [ -f /usr/share/bash-completion/bash_completion ]; then
        . /usr/share/bash-completion/bash_completion
    elif [ -f /etc/bash_completion ]; then
        . /etc/bash_completion
    fi
fi

# Export common development environment variables
export EDITOR=nvim
export VISUAL=nvim
export BROWSER=firefox
export PATH="$HOME/bin:$HOME/.local/bin:$PATH"

# Use official fzf directory completion for cd
if command -v fzf >/dev/null 2>&1 && declare -F _fzf_dir_completion >/dev/null 2>&1; then
    # Remove any existing cd completion and use fzf's directory completion
    complete -r cd 2>/dev/null || true
    complete -F _fzf_dir_completion -o default -o bashdefault cd
fi
